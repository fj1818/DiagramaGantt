/**
 * DiagramaGanttCustom - Aplicaci√≥n Principal
 * 
 * @description Punto de entrada principal que inicializa y coordina todos los componentes
 * @author DiagramaGanttCustom Team
 * @version 1.0.0
 */

import Toolbar from './components/Toolbar.js';
import TaskTableModal from './components/TaskTableModal.js';

class DiagramaGanttApp {
    constructor() {
        // Estado global de la aplicaci√≥n
        this.state = {
            isInitialized: false,
            currentProject: null,

            // Estado persistente (guardado en localStorage)
            persistent: {
                tasks: [],
                headers: {
                    proyecto: 'Proyecto',
                    tarea: 'Tarea'
                },
                settings: this.getDefaultSettings(),
                view: {
                    type: 'daily',
                    scale: 1,
                    startDate: null,
                    endDate: null
                }
            },

            // Estado de sesi√≥n (temporal durante la sesi√≥n)
            session: {
                tasks: [],
                headers: {
                    proyecto: 'Proyecto',
                    tarea: 'Tarea'
                },
                hasChanges: false
            }
        };

        // Componentes de la aplicaci√≥n
        this.components = {
            toolbar: null,
            taskTableModal: null,
            taskTable: null,
            canvasRenderer: null,
            viewManager: null,
            styleManager: null,
            exportManager: null
        };

        // Configuraci√≥n de la aplicaci√≥n
        this.config = {
            version: '1.0.0',
            autoSaveInterval: 300000, // 5 minutos
            maxTasksPerProject: 1000,
            supportedFormats: ['json'],
            canvas: {
                minWidth: 800,
                minHeight: 400,
                maxZoom: 3,
                minZoom: 0.5
            }
        };

        this.init();
    }

    /**
     * Inicializa la aplicaci√≥n
     */
    async init() {
        try {
            console.log('üöÄ Iniciando DiagramaGanttCustom...');

            // Mostrar loading
            this.showLoadingScreen(true);

            // Verificar soporte del navegador
            this.checkBrowserSupport();

            // Inicializar componentes
            await this.initializeComponents();

            // Configurar comunicaci√≥n entre componentes
            this.setupComponentCommunication();

            // Configurar estado inicial
            this.setupInitialState();

            // Ocultar loading
            this.showLoadingScreen(false);

            // Marcar como inicializada
            this.state.isInitialized = true;

            console.log('‚úÖ DiagramaGanttCustom inicializada correctamente');
            this.showNotification('Aplicaci√≥n lista para usar', 'success');

        } catch (error) {
            this.handleCriticalError('Error cr√≠tico al inicializar aplicaci√≥n', error);
        }
    }

    /**
     * Verifica soporte del navegador
     */
    checkBrowserSupport() {
        const requiredFeatures = {
            'Canvas HTML5': () => {
                const canvas = document.createElement('canvas');
                return !!(canvas.getContext && canvas.getContext('2d'));
            },
            'ES6 Modules': () => 'noModule' in HTMLScriptElement.prototype,
            'File API': () => 'FileReader' in window,
            'Local Storage': () => 'localStorage' in window,
            'CSS Grid': () => CSS.supports('display', 'grid'),
            'CSS Custom Properties': () => CSS.supports('color', 'var(--test)')
        };

        const unsupported = [];
        for (const [feature, test] of Object.entries(requiredFeatures)) {
            if (!test()) {
                unsupported.push(feature);
            }
        }

        if (unsupported.length > 0) {
            throw new Error(`Navegador no compatible. Funciones faltantes: ${unsupported.join(', ')}`);
        }
    }

    /**
     * Inicializa todos los componentes
     */
    async initializeComponents() {
        console.log('üîß Inicializando componentes...');

        // Inicializar Toolbar (ya implementado)
        this.components.toolbar = new Toolbar();

        // Inicializar TaskTableModal (FASE 2)
        this.components.taskTableModal = new TaskTableModal({
            onGenerate: this.handleGenerateDiagram.bind(this),
            onCancel: this.handleTaskModalCancel.bind(this),
            onTaskAdd: this.handleTaskAdd.bind(this),
            onTaskDelete: this.handleTaskDelete.bind(this),
            onTaskUpdate: this.handleTaskUpdate.bind(this),
            onTemporaryChange: this.handleModalChanges.bind(this) // Nuevo callback para cambios temporales
        });

        // TODO: Inicializar otros componentes cuando est√©n implementados
        /*
        this.components.taskTable = new TaskTable();
        this.components.canvasRenderer = new CanvasRenderer();
        this.components.viewManager = new ViewManager();
        this.components.styleManager = new StyleManager();
        this.components.exportManager = new ExportManager();
        */

        console.log('‚úÖ Componentes inicializados');
    }

    /**
     * Configura comunicaci√≥n entre componentes
     */
    setupComponentCommunication() {
        console.log('üîó Configurando comunicaci√≥n entre componentes...');

        // Configurar callbacks del Toolbar
        this.components.toolbar.setCallbacks({
            onAddTask: this.handleOpenTaskModal.bind(this),
            onSave: this.handleSave.bind(this),
            onLoad: this.handleLoad.bind(this),
            onViewChange: this.handleViewChange.bind(this),
            onCustomizationChange: this.handleCustomizationChange.bind(this)
        });

        // TODO: Configurar comunicaci√≥n con otros componentes

        console.log('‚úÖ Comunicaci√≥n configurada');
    }

    /**
     * Configura estado inicial de la aplicaci√≥n
     */
    setupInitialState() {
        console.log('‚öôÔ∏è Configurando estado inicial...');

        // Establecer fechas por defecto
        const now = new Date();
        this.state.persistent.view.startDate = new Date(now.getFullYear(), now.getMonth(), 1);
        this.state.persistent.view.endDate = new Date(now.getFullYear(), now.getMonth() + 3, 0);

        // Solo cargar localStorage si hay tareas v√°lidas (no cargar autom√°ticamente para evitar cache persistente)
        this.loadFromLocalStorageIfValid();

        // Configurar auto-guardado
        this.setupAutoSave();

        // Inicializar estado de sesi√≥n con estado persistente
        this.initializeSessionState();

        console.log('‚úÖ Estado inicial configurado');
    }

    /**
     * Abre el modal de gesti√≥n de tareas
     */
    async handleOpenTaskModal() {
        try {
            console.log('üìã Abriendo modal de gesti√≥n de tareas...');
            console.log('üîÑ Estado de sesi√≥n actual:', {
                tasks: this.state.session.tasks.length,
                hasChanges: this.state.session.hasChanges
            });

            // Abrir modal con estado de sesi√≥n (cambios temporales durante la sesi√≥n)
            await this.components.taskTableModal.open(this.state.session.tasks, this.state.session.headers);

            return { success: true };
        } catch (error) {
            console.error('Error al abrir modal de tareas:', error);
            return { success: false, error: error.message };
        }
    }

    /**
     * Maneja la generaci√≥n del diagrama desde el modal
     */
    async handleGenerateDiagram(tasks, headers = null) {
        try {
            console.log('üöÄ Generando diagrama con tareas:', tasks);
            if (headers) {
                console.log('üìã Headers personalizados:', headers);
            }

            // Actualizar estado de sesi√≥n
            this.state.session.tasks = [...tasks];
            if (headers) {
                this.state.session.headers = {...headers };
            }
            this.state.session.hasChanges = false; // Se acaba de guardar

            // Actualizar estado persistente (se guardar√° en localStorage)
            this.state.persistent.tasks = [...tasks];
            if (headers) {
                this.state.persistent.headers = {...headers };
            }
            this.state.currentProject = this.generateProjectData();

            // Marcar como modificado para el toolbar
            this.components.toolbar.state.hasUnsavedChanges = true;
            this.components.toolbar.updateButtonStates();

            // Guardar en localStorage
            await this.saveToLocalStorage();

            // TODO: Actualizar canvas y vista cuando est√©n implementados
            this.updateAllComponents();

            // Notificar √©xito
            const headerInfo = headers ? ` (${headers.proyecto}: ${headers.tarea})` : '';
            this.showNotification(`Diagrama generado con ${tasks.length} tareas${headerInfo}`, 'success');

            return { success: true };
        } catch (error) {
            console.error('Error al generar diagrama:', error);
            return { success: false, error: error.message };
        }
    }

    /**
     * Maneja cancelaci√≥n del modal de tareas (usuario confirm√≥ cancelar)
     */
    async handleTaskModalCancel() {
        console.log('‚ùå Modal de tareas cancelado por el usuario');
        // Los cambios temporales se mantienen para la pr√≥xima apertura del modal en la misma sesi√≥n
        // No necesitamos hacer nada aqu√≠, los cambios se quedan en session
        return { success: true };
    }

    /**
     * Maneja adici√≥n de tarea en el modal
     */
    handleTaskAdd(task) {
        console.log('‚ûï Tarea agregada en modal:', task.id);
    }

    /**
     * Maneja eliminaci√≥n de tarea en el modal
     */
    handleTaskDelete(task) {
        console.log('üóëÔ∏è Tarea eliminada en modal:', task.id);
    }

    /**
     * Maneja actualizaci√≥n de tarea en el modal
     */
    handleTaskUpdate(task, field, oldValue, newValue) {
        console.log(`üìù Tarea ${task.id} actualizada: ${field} = ${newValue}`);
    }

    /**
     * Genera datos del proyecto basado en las tareas (usa estado de sesi√≥n)
     */
    generateProjectData() {
        const projects = {};

        this.state.session.tasks.forEach(task => {
            if (!projects[task.proyecto]) {
                projects[task.proyecto] = {
                    nombre: task.proyecto,
                    tareas: [],
                    fechaInicio: task.fechaInicio,
                    fechaFin: task.fechaFin
                };
            }

            projects[task.proyecto].tareas.push(task);

            // Actualizar fechas del proyecto
            if (task.fechaInicio < projects[task.proyecto].fechaInicio) {
                projects[task.proyecto].fechaInicio = task.fechaInicio;
            }
            if (task.fechaFin > projects[task.proyecto].fechaFin) {
                projects[task.proyecto].fechaFin = task.fechaFin;
            }
        });

        return Object.values(projects);
    }

    /**
     * Maneja guardado de diagrama
     */
    async handleSave() {
        try {
            console.log('üíæ Guardando diagrama...');

            const data = this.exportData();
            this.downloadJSON(data, `diagrama-gantt-${Date.now()}.json`);

            await this.saveToLocalStorage();

            return { success: true };
        } catch (error) {
            console.error('Error al guardar:', error);
            return { success: false, error: error.message };
        }
    }

    /**
     * Maneja carga de diagrama
     */
    async handleLoad(data) {
        try {
            console.log('üìÅ Cargando diagrama...');

            // Validar estructura de datos
            this.validateImportData(data);

            // Importar datos
            this.importData(data);

            // Guardar en localStorage
            await this.saveToLocalStorage();

            // Actualizar vista
            this.updateAllComponents();

            return { success: true };
        } catch (error) {
            console.error('Error al cargar:', error);
            return { success: false, error: error.message };
        }
    }

    /**
     * Maneja cambio de vista
     */
    async handleViewChange(viewType, sprintStartDate = null) {
        try {
            console.log(`üîÑ Cambiando vista a: ${viewType}`);

            this.state.persistent.view.type = viewType;

            if (viewType === 'sprint' && sprintStartDate) {
                this.state.persistent.view.sprintStart = sprintStartDate;
            }

            // TODO: Actualizar canvas y componentes relacionados
            this.updateAllComponents();

            return { success: true };
        } catch (error) {
            console.error('Error al cambiar vista:', error);
            return { success: false, error: error.message };
        }
    }

    /**
     * Maneja cambios de personalizaci√≥n
     */
    async handleCustomizationChange(settings) {
        try {
            console.log('üé® Aplicando personalizaci√≥n...');

            this.state.persistent.settings = {...this.state.persistent.settings, ...settings };

            // TODO: Aplicar estilos a componentes
            this.updateAllComponents();

            return { success: true };
        } catch (error) {
            console.error('Error al aplicar personalizaci√≥n:', error);
            return { success: false, error: error.message };
        }
    }

    /**
     * Actualiza todos los componentes
     */
    updateAllComponents() {
        // TODO: Implementar actualizaci√≥n de componentes
        console.log('üîÑ Actualizando componentes...');
    }

    /**
     * Exporta datos de la aplicaci√≥n (usa estado persistente para archivos JSON)
     */
    exportData() {
        return {
            version: this.config.version,
            created: new Date().toISOString(),
            modified: new Date().toISOString(),
            projects: this.getProjectsData(),
            tasks: this.state.persistent.tasks,
            headers: this.state.persistent.headers,
            settings: this.state.persistent.settings,
            view: this.state.persistent.view
        };
    }

    /**
     * Importa datos a la aplicaci√≥n (actualiza tanto estado persistente como de sesi√≥n)
     */
    importData(data) {
        // Validar versi√≥n
        if (data.version && this.isVersionCompatible(data.version)) {
            // Actualizar estado persistente
            this.state.persistent.tasks = data.tasks || [];
            this.state.persistent.headers = data.headers || { proyecto: 'Proyecto', tarea: 'Tarea' };
            this.state.persistent.settings = {...this.getDefaultSettings(), ...data.settings };
            this.state.persistent.view = {...this.state.persistent.view, ...data.view };

            // Sincronizar estado de sesi√≥n con los datos importados
            this.syncSessionWithPersistent();
        } else {
            throw new Error('Versi√≥n de archivo no compatible');
        }
    }

    /**
     * Valida datos de importaci√≥n
     */
    validateImportData(data) {
        if (!data || typeof data !== 'object') {
            throw new Error('Archivo JSON inv√°lido');
        }

        if (data.tasks && !Array.isArray(data.tasks)) {
            throw new Error('Formato de tareas inv√°lido');
        }

        // Validar estructura de tareas
        if (data.tasks) {
            for (const task of data.tasks) {
                this.validateTask(task);
            }
        }
    }

    /**
     * Valida estructura de tarea
     */
    validateTask(task) {
        const required = ['id', 'proyecto', 'tarea', 'fechaInicio', 'fechaFin', 'color'];
        for (const field of required) {
            if (!task[field]) {
                throw new Error(`Campo requerido faltante en tarea: ${field}`);
            }
        }

        // Validar formato de fechas
        if (!/^\d{4}-\d{2}-\d{2}$/.test(task.fechaInicio) ||
            !/^\d{4}-\d{2}-\d{2}$/.test(task.fechaFin)) {
            throw new Error('Formato de fecha inv√°lido en tarea');
        }

        // Validar color hexadecimal
        if (!/^#[0-9A-Fa-f]{6}$/.test(task.color)) {
            throw new Error('Formato de color inv√°lido en tarea');
        }
    }

    /**
     * Obtiene configuraci√≥n por defecto
     */
    getDefaultSettings() {
        return {
            colores: {
                fondoDiagrama: "#FFFFFF",
                encabezados: "#2196F3",
                bordes: "#E0E0E0",
                celdas: "#F5F5F5"
            },
            fuentes: {
                encabezados: { tipo: "Arial", tama√±o: 14 },
                proyectos: { tipo: "Arial", tama√±o: 12 },
                tareas: { tipo: "Arial", tama√±o: 12 }
            }
        };
    }

    /**
     * Obtiene datos de proyectos (usa estado de sesi√≥n)
     */
    getProjectsData() {
        const projects = {};
        this.state.session.tasks.forEach(task => {
            if (!projects[task.proyecto]) {
                projects[task.proyecto] = {
                    nombre: task.proyecto,
                    tareas: []
                };
            }
            projects[task.proyecto].tareas.push(task);
        });
        return Object.values(projects);
    }

    /**
     * Verifica compatibilidad de versi√≥n
     */
    isVersionCompatible(version) {
        // Implementar l√≥gica de compatibilidad
        return version === this.config.version;
    }

    /**
     * Genera ID √∫nico
     */
    generateId() {
        return `task_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    }

    /**
     * Descarga archivo JSON
     */
    downloadJSON(data, filename) {
        const blob = new Blob([JSON.stringify(data, null, 2)], {
            type: 'application/json'
        });

        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = filename;
        a.style.display = 'none';

        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);

        URL.revokeObjectURL(url);
    }

    /**
     * Guarda en localStorage
     */
    async saveToLocalStorage() {
        try {
            const data = this.exportData();
            localStorage.setItem('diagramaGantt_data', JSON.stringify(data));
            localStorage.setItem('diagramaGantt_lastSave', new Date().toISOString());
        } catch (error) {
            console.warn('Error al guardar en localStorage:', error);
        }
    }

    /**
     * Carga desde localStorage
     */
    loadFromLocalStorage() {
        try {
            const data = localStorage.getItem('diagramaGantt_data');
            if (data) {
                const parsed = JSON.parse(data);
                this.importData(parsed);
                console.log('‚úÖ Datos cargados desde localStorage');
            }
        } catch (error) {
            console.warn('Error al cargar desde localStorage:', error);
        }
    }

    /**
     * Carga desde localStorage solo si hay tareas v√°lidas (evita cache vac√≠o persistente)
     */
    loadFromLocalStorageIfValid() {
        try {
            const data = localStorage.getItem('diagramaGantt_data');
            if (data) {
                const parsed = JSON.parse(data);

                // Solo cargar si hay tareas reales, no solo configuraci√≥n vac√≠a
                if (parsed.tasks && parsed.tasks.length > 0 && parsed.tasks.some(task =>
                        task.proyecto && task.proyecto.trim().length > 0
                    )) {
                    this.importData(parsed);
                    console.log('‚úÖ Datos v√°lidos cargados desde localStorage:', parsed.tasks.length, 'tareas');
                } else {
                    console.log('üìù Iniciando con estado limpio (sin tareas previas v√°lidas)');
                    // Limpiar localStorage si solo tiene datos vac√≠os
                    localStorage.removeItem('diagramaGantt_data');
                    localStorage.removeItem('diagramaGantt_lastSave');
                }
            } else {
                console.log('üìù Iniciando con estado limpio (primera vez)');
            }
        } catch (error) {
            console.warn('Error al validar localStorage, iniciando limpio:', error);
            // En caso de error, limpiar localStorage corrupto
            localStorage.removeItem('diagramaGantt_data');
            localStorage.removeItem('diagramaGantt_lastSave');
        }
    }

    /**
     * Inicializa el estado de sesi√≥n SIEMPRE VAC√çO (sin importar localStorage)
     */
    initializeSessionState() {
        // El estado de sesi√≥n SIEMPRE inicia vac√≠o
        this.state.session.tasks = [];
        this.state.session.headers = {
            proyecto: 'Proyecto',
            tarea: 'Tarea'
        };
        this.state.session.hasChanges = false;

        console.log('üîÑ Estado de sesi√≥n inicializado VAC√çO:', {
            tasks: this.state.session.tasks.length,
            headers: this.state.session.headers,
            persistent_tasks: this.state.persistent.tasks.length
        });
    }

    /**
     * Maneja cambios temporales en el modal (sin guardar)
     */
    handleModalChanges(tasks, headers) {
        console.log('üìù Actualizando estado temporal de sesi√≥n');
        this.state.session.tasks = [...tasks];
        this.state.session.headers = {...headers };
        this.state.session.hasChanges = true;
    }

    /**
     * Sincroniza estado de sesi√≥n con estado persistente (usado despu√©s de cargar archivos)
     */
    syncSessionWithPersistent() {
        console.log('üîÑ Sincronizando sesi√≥n con estado persistente');
        this.state.session.tasks = [...this.state.persistent.tasks];
        this.state.session.headers = {...this.state.persistent.headers };
        this.state.session.hasChanges = false;
    }

    /**
     * Descarta cambios temporales y restaura estado persistente
     */
    discardSessionChanges() {
        console.log('üîÑ Descartando cambios de sesi√≥n, restaurando estado persistente');
        this.syncSessionWithPersistent();
    }

    /**
     * Configura auto-guardado
     */
    setupAutoSave() {
        this.autoSaveInterval = setInterval(() => {
            if (this.state.isInitialized) {
                this.saveToLocalStorage();
            }
        }, this.config.autoSaveInterval);
    }

    /**
     * Muestra/oculta pantalla de carga
     */
    showLoadingScreen(show) {
        const loadingScreen = document.getElementById('loading-screen');
        if (loadingScreen) {
            if (show) {
                loadingScreen.classList.remove('hidden');
            } else {
                loadingScreen.classList.add('hidden');
                setTimeout(() => {
                    loadingScreen.style.display = 'none';
                }, 300);
            }
        }
    }

    /**
     * Muestra notificaci√≥n
     */
    showNotification(message, type = 'info') {
        // TODO: Implementar sistema de notificaciones completo
        console.log(`[${type.toUpperCase()}] ${message}`);
    }

    /**
     * Maneja errores cr√≠ticos
     */
    handleCriticalError(context, error) {
        console.error(`üí• ${context}:`, error);

        // Mostrar mensaje de error al usuario
        const errorMessage = `${context}: ${error.message}`;

        // Crear elemento de error si no existe
        let errorContainer = document.getElementById('critical-error');
        if (!errorContainer) {
            errorContainer = document.createElement('div');
            errorContainer.id = 'critical-error';
            errorContainer.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(244, 67, 54, 0.9);
                color: white;
                display: flex;
                flex-direction: column;
                justify-content: center;
                align-items: center;
                z-index: 10000;
                font-family: system-ui, -apple-system, sans-serif;
                text-align: center;
                padding: 2rem;
            `;
            document.body.appendChild(errorContainer);
        }

        errorContainer.innerHTML = `
            <h1>üí• Error Cr√≠tico</h1>
            <p>${errorMessage}</p>
            <p><small>Por favor, recarga la p√°gina para intentar nuevamente.</small></p>
            <button onclick="location.reload()" style="
                background: white;
                color: #f44336;
                border: none;
                padding: 1rem 2rem;
                border-radius: 0.5rem;
                cursor: pointer;
                font-weight: bold;
                margin-top: 1rem;
            ">Recargar P√°gina</button>
        `;
    }

    /**
     * Obtiene estado de la aplicaci√≥n
     */
    getState() {
        return {...this.state };
    }

    /**
     * Destruye la aplicaci√≥n
     */
    destroy() {
        // Limpiar intervalos
        if (this.autoSaveInterval) {
            clearInterval(this.autoSaveInterval);
        }

        // Destruir componentes
        Object.values(this.components).forEach(component => {
            if (component && typeof component.destroy === 'function') {
                component.destroy();
            }
        });

        console.log('üßπ Aplicaci√≥n destruida');
    }
}

// Inicializar aplicaci√≥n cuando el DOM est√© listo
document.addEventListener('DOMContentLoaded', () => {
    window.diagramaGanttApp = new DiagramaGanttApp();
});

// Manejar errores globales
window.addEventListener('error', (event) => {
    console.error('Error global capturado:', event.error);
});

window.addEventListener('unhandledrejection', (event) => {
    console.error('Promise rechazada no manejada:', event.reason);
});

export default DiagramaGanttApp;